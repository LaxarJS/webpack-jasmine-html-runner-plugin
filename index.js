/**
 * Copyright 2016 aixigo AG
 * Released under the MIT license.
 * http://laxarjs.org/license
 */

/**
 * Helps to do *interactive in-browser testing* with webpack.
 * Generates a `spec-runner.html` file and a JS bundle with sourcemaps for each `spec-runner.js`.
 *
 * The HTML spec-runner is generated by the custom `JasmineHtmlRunnerWebpackPlugin`, and also uses
 * sourcemapped-stacktrace to look up source positions at runtime.
 */

/* eslint-env node */

const path = require( 'path' );
const glob = require( 'glob' );

module.exports = WebpackJasmineHtmlRunnerPlugin;

WebpackJasmineHtmlRunnerPlugin.entry = entry;

/**
 * Generates webpack entry points suitable for use with the WebpackJasmineHtmlRunnerPlugin plugin.
 * Basically, each file matching one of the provided glob-patterns becomes an entry point which is named
 * like that file, but without the extension.
 *
 * @param {...String} patterns
 *   File patterns in glob-syntax (may contain * and **).
 *
 * @return {Object} entry points for use as webpack `entry` configuration, as an object.
 */
function entry() {
   const patterns = Array.from( arguments );
   const entry = {};
   patterns.forEach( globPattern => {
      // backwards compatibility:
      const pattern = globPattern.replace( '[name]', '**' );
      return glob.sync( pattern ).forEach( path => {
         const baseName = path.replace( /\.[^.]+$/, '' );
         entry[ baseName ] = path;
      } );
   } );
   return entry;
}

const fixupDependencies = {
   'fixup-stacktraces': [ 'sourcemapped-stacktrace' ],
   'fixup-json-messages': [
      'jsondiffpatch/public/build/jsondiffpatch',
      'jsondiffpatch/public/build/jsondiffpatch-formatters'
   ]
};

const fixupStyles = {
   'fixup-json-messages': [
      'jsondiffpatch/public/formatters-styles/html.css'
   ]
};

/**
 * Generates webpack entry points suitable for use with the WebpackJasmineHtmlRunnerPlugin plugin.
 *
 * @param {Object} optionalOptions
 *   Various options to control the generated spec runners.
 *
 * @param {String[]} [optionalOptions.fixupScripts]
 *   One or more of these (default: all):
 *    - 'fix-stacktraces': applies sourcemap lookup
 *    - 'fix-json-messages': applies JSON formatting
 *
 * @param {String[]} [optionalOptions.includePaths]
 *   Absolute paths to additional scripts that should be loaded by the HTML spec runner (after Jasmine has
 *   been loaded).
 */
function WebpackJasmineHtmlRunnerPlugin( optionalOptions ) {
   const options = Object.assign( {
      cwd: process.cwd(),
      jasminePath: null,
      stylePaths: [],
      includePaths: [],
      fixupScripts: [ 'fixup-stacktraces', 'fixup-json-messages' ],
      pattern: /.*\bspec\b.*/i
   }, optionalOptions || {} );

   options.jasminePath = options.jasminePath || path.resolve(
      options.cwd, resolve( 'jasmine-core' ).replace( /.js$/, '' )
   );

   this.apply = function( compiler ) {
      compiler.plugin( 'emit', ( compilation, done ) => {
         compilation.chunks
            .filter( chunk => options.pattern.test( chunk.name ) )
            .forEach( chunk => {
               const stylePaths = options.stylePaths.slice();
               const includePaths = options.includePaths.slice();
               options.fixupScripts.forEach( name => {
                  ( fixupDependencies[ name ] || [] ).forEach( dep => {
                     includePaths.push( require.resolve( dep ) );
                  } );
                  ( fixupStyles[ name ] || [] ).forEach( cssDep => {
                     stylePaths.push( require.resolve( cssDep ) );
                  } );
                  includePaths.push( require.resolve( `./lib/${name}` ) );
               } );

               const chunkPath = path.resolve( options.cwd, `${chunk.name}.html` );
               const specPath = path.resolve( options.cwd, `${chunk.name}.bundle.js` );
               const specUrl = path.relative( path.dirname( chunkPath ), specPath );
               const styleUrls = stylePaths.map( p => path.relative( chunkPath, p ) );
               const includeUrls = includePaths.map( p => path.relative( chunkPath, p ) );
               const context = Object.assign( {}, {
                  specUrl,
                  title: `${options.title || 'Spec:'} ${path.basename( chunk.name )}`,
                  jasmineUrl: path.relative( chunkPath, options.jasminePath ),
                  styleUrls,
                  includeUrls
               }, options );

               const source = expand( context );
               compilation.assets[ `${chunk.name}.html` ] = {
                  source: () => source,
                  size: () => source.length
               };
            } );
         done();
      } );
   };

   function expand( ctx ) {
      return `<!doctype html>
         <html>
           <head>
              <meta charset="utf-8">
              <meta http-equiv="X-UA-Compatible" content="IE=edge">
              <title>${ctx.title}</title>
              <link type="text/css" rel="stylesheet" href="${ctx.jasmineUrl}/jasmine.css">
              ${ctx.styleUrls.map(
                 url => `<link type="text/css" rel="stylesheet" href="${url}">`
              ).join('\n              ')}
              <script type="text/javascript" src="${ctx.jasmineUrl}/jasmine.js"></script>
              <script type="text/javascript" src="${ctx.jasmineUrl}/jasmine-html.js"></script>
              <script type="text/javascript" src="${ctx.jasmineUrl}/boot.js"></script>
              ${ctx.includeUrls.map(
                  url => `<script type="text/javascript" src="${url}"></script>`
              ).join('\n              ')}
           </head>
           <body>
             <script type="text/javascript" src="${ctx.specUrl}"></script>
             <style>
              .webpack-jasmine-fixup-json-message:hover {
                 cursor: pointer;
                 background: white;
              }
             </style>
           </body>
         </html>
      `;
   }
}

function resolve( modulePath ) {
   return require.resolve( modulePath );
}
