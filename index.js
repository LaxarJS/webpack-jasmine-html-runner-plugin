/**
 * Copyright 2016 aixigo AG
 * Released under the MIT license.
 * http://laxarjs.org/license
 */

/**
 * Helps to do *interactive in-browser testing* with webpack.
 * Generates a `spec-runner.html` file and a JS bundle with sourcemaps for each `spec-runner.js`.
 *
 * The HTML spec-runner is generated by the custom `JasmineHtmlRunnerWebpackPlugin`, and also uses
 * sourcemapped-stacktrace to look up source positions at runtime.
 */

/* eslint-env node */

const path = require( 'path' );
const glob = require('glob');

module.exports = WebpackJasmineHtmlRunnerPlugin;

WebpackJasmineHtmlRunnerPlugin.entry = entry;


/**
 * Takes a file pattern of the form './path/to/[name]/spec-runner.js'.
 * The [name]-portion of the path is matched using a '**' glob-expression, so it may contain subfolders.
 *
 * Returns entry points for use as webpack `entry` configuration, as an object.
 */
function entry( pattern ) {
   const globPattern = pattern.replace( '[name]', '**' );
   const regexPattern = pattern.replace( '[name]', '(.*)' );
   return glob.sync( globPattern )
      .reduce( ( acc, path ) => {
         const match = path.match( regexPattern );
         if( match && match[ 1 ] ) {
            acc[ match[ 1 ] + '/spec-runner' ] = path;
         }
         return acc;
      }, {} );
}

function WebpackJasmineHtmlRunnerPlugin( optionalOptions ) {
   const options = Object.assign( {
      cwd: process.cwd(),
      includePaths: [],
      jasminePath: null,
      sourceMappedStackTracePath: null,
      pattern: /(.*)\bspec-runner/
   }, optionalOptions || {} );

   options.jasminePath = options.jasminePath || path.resolve(
      options.cwd, require.resolve( 'jasmine-core/lib/jasmine-core' )
   );

   options.sourceMappedStackTracePath = options.sourceMappedStackTracePath || path.resolve(
      options.cwd, require.resolve( './node_modules/sourcemapped-stacktrace/dist' )
   );

   this.apply = function( compiler ) {
      compiler.plugin('emit', ( compilation, done ) => {
         compilation.chunks
            .filter( chunk => options.pattern.test( chunk.name ) )
            .forEach( ( chunk ) => {
               const chunkPath = path.resolve( options.cwd, `${chunk.name}.html` );
               const context = Object.assign( {}, {
                  title: `${chunk.name} Spec ${ options.title || '' }`,
                  jasmineUrl: path.relative( chunkPath, context.jasminePath ),
                  sourceMappedStackTraceUrl: path.relative( chunkPath, context.sourceMappedStackTracePath ),
                  includeUrls: context.includePaths.map( p => path.relative( chunkPath, p ) )
               }, options );

               const source = expand( context );
               compilation.assets[ `${chunk.name}.html` ] = {
                  source: () => source,
                  size: () => source.length
               };
            } );
         done();
      } );
   };

   function expand( ctx ) {
      return `<!doctype html>
         <html>
           <head>
              <meta charset="utf-8">
              <meta http-equiv="X-UA-Compatible" content="IE=edge">
              <title>${ctx.title}</title>
              <link type="text/css" rel="stylesheet" href="${ctx.jasmineUrl}/jasmine.css">
              ${ ctx.includeUrls.map( url => `<script type="text/javascript" src="${url}"></script>` ) }
              <script type="text/javascript" src="${ctx.jasmineUrl}/jasmine.js"></script>
              <script type="text/javascript" src="${ctx.jasmineUrl}/jasmine-html.js"></script>
              <script type="text/javascript" src="${ctx.jasmineUrl}/boot.js"></script>

              <script type="text/javascript" src="${ctx.sourceMappedStackTraceUrl}/sourcemapped-stacktrace.js"></script>
              <script type="text/javascript">
               // Fixup stack traces, using this approach: https://gist.github.com/guncha/f45ceef6d483c384290a
               jasmine.getEnv().addReporter( {
                  jasmineDone: function() {
                     try {
                        var traces = document.querySelectorAll( '.jasmine-stack-trace' );
                        [].slice.call( traces ).forEach( function( node ) {
                           sourceMappedStackTrace.mapStackTrace( node.textContent, function( stack ) {
                              node.textContent = node.previousSibling.textContent + "\\n" + stack.join( "\\n" );
                           } );
                        } );
                     }
                     catch(e) { /* ok, just an unsupported browser */ }
                  }
               } );
               </script>
           </head>
           <body>
             <script type="text/javascript" src="spec-runner.bundle.js"></script>
           </body>
         </html>
      `;
   }
}
