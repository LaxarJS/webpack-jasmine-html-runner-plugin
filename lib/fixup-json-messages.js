/**
 * Copyright 2016 aixigo AG
 * Released under the MIT license.
 * http://laxarjs.org/license
 */

/* eslint-disable no-var, prefer-arrow-callback */
/* global jsondiffpatch, document, console */

// Improves `toEqual` and `toHaveBeenCalledWith` reporting with big nested JSON structures.
(function() {

   jasmine.getEnv().addReporter( { jasmineDone: fixJsonMessages } );

   const NEWLINE_MARKER = '__WEBPACK_JASMINE_HTML_PLUGIN_FIXUP_NEWLINE_MARKER__';
   const NEWLINE_MATCHER = RegExp( NEWLINE_MARKER, 'g' );


   function fixJsonMessages() {
      var resultMessages = document.querySelectorAll( '.jasmine-result-message' );
      [].slice.call( resultMessages )
         .forEach( fixMessage );
   }

   ///////////////////////////////////////////////////////////////////////////////////////////////////////////

   function processToEqual( textContent ) {
      // using [\s\S] to match newline as well
      var matcher = /^(Expected )([\s\S]*?) ((?:not )?to (?:equal|be) )([\s\S]*?)\.$/;
      var matches = textContent.match( matcher );
      return matches && {
         prefix: matches[ 1 ],
         left: matches[ 2 ],
         relationText: matches[ 3 ],
         right: matches[ 4 ]
      };
   }

   ///////////////////////////////////////////////////////////////////////////////////////////////////////////

   function processToHaveBeenCalledWith( textContent ) {
      // eslint-disable-next-line max-len
      var matcher = /^(Expected spy (?:[\s\S]*?) (?:not )?to have been called with )([\s\S]*)( but actual calls were )([\s\S]*)\.$/;
      var matches = textContent.match( matcher );
      return matches && {
         prefix: matches[ 1 ],
         left: matches[ 2 ],
         relationText: matches[ 3 ],
         right: matches[ 4 ]
      };
   }

   ///////////////////////////////////////////////////////////////////////////////////////////////////////////

   function fixMessage( node ) {
      var textContent = node.textContent;

      var match =
         processToEqual( textContent ) ||
         processToHaveBeenCalledWith( textContent );

      if( !match ) {
         return;
      }

      node.setAttribute( 'title', textContent );

      var left = parse( match.left );
      var right = parse( match.right );

      const pre = document.createElement( 'pre' );
      pre.innerText = [
         match.prefix,
         format( left ),
         match.relationText,
         format( right )
      ].join( '\n\n' );
      node.innerHTML = '';
      node.appendChild( pre );

      var diffContainer;
      if( left.length !== right.length || jsondiffpatch.diff( left[ 0 ], right[ 0 ] ) ) {
         node.className = 'webpack-jasmine-fixup-json-message';
         node.addEventListener( 'click', function() {
            if( diffContainer ) {
               diffContainer.parentNode.removeChild( diffContainer );
               diffContainer = null;
               return;
            }
            diffContainer = document.createElement( 'DIV' );
            diffContainer.innerHTML = '<h3>diff:</h3>';
            // multiple right values occur e.g. when using toHaveBeenCalledWith
            right.forEach( function( rightItem ) {
               var delta = jsondiffpatch.diff( left[ 0 ], rightItem );
               diffContainer.innerHTML += '<br>' + jsondiffpatch.formatters.html
                  .format( delta, left )
                  .replace( NEWLINE_MATCHER, '\n' );
            } );
            node.appendChild( diffContainer );
         } );
      }
   }

   ///////////////////////////////////////////////////////////////////////////////////////////////////////////

   function format( value ) {
      // value was wrapped in array for parsing:
      try {
         return value.map( function( item ) {
            return JSON.stringify( item, null, 3 ).replace( NEWLINE_MATCHER, '\n' );
         } ).join( ',\n' );
      }
      catch( e ) {
         // value not JSON-compatible
         return value;
      }
   }

   ///////////////////////////////////////////////////////////////////////////////////////////////////////////

   function parse( source ) {
      // Must use eval since Jasmine produces no valid JSON (unquoted object keys, Object constructor)
      try {
         // Because the source code is an expression generated by jasmine, newlines should only occur as part
         // of strings (the otherwise missing newlines are the reason that this fixup script exists).
         const oneLineSource = source.replace( '\n', NEWLINE_MARKER );
         // eslint-disable-next-line no-eval
         return eval( '[ ' + oneLineSource + ' ]' );
      }
      catch( e ) {
         var msg = 'webpack-jasmine-html-runner-plugin: fixup-json-messages: could not parse message part: ';
         // eslint-disable-next-line no-console
         console.info( msg, source );
         return source;
      }
   }

})();
